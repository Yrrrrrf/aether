import type { DatabaseSchema, Table } from "../ast/types.ts";

export function generateZod(schema: DatabaseSchema): string {
  const lines: string[] = [];

  lines.push(`// Generated by Aether Oracle (Zod)`);
  lines.push(`import { z } from "zod";`);
  lines.push(``);

  // Enums
  for (const enm of schema.enums) {
    const enumName = toPascalCase(enm.name) + "Schema";
    // Zod enum requires non-empty array of strings
    if (enm.values.length > 0) {
      // [val1, val2, ...]
      const values = enm.values.map((v) => `"${v}"`).join(", ");
      lines.push(`export const ${enumName} = z.enum([${values}]);`);
    } else {
      lines.push(
        `export const ${enumName} = z.string(); // Empty enum fallback`,
      );
    }
    lines.push(``);
  }

  // Tables
  for (const table of schema.tables) {
    lines.push(...generateTableZod(table, schema));
    lines.push(``);
  }

  return lines.join("\n");
}

function generateTableZod(table: Table, schema: DatabaseSchema): string[] {
  const lines: string[] = [];
  const schemaName = toPascalCase(table.name) + "Schema";

  lines.push(`export const ${schemaName} = z.object({`);

  for (const col of table.columns) {
    let zodType = "z.unknown()";

    // Check Enum
    const foundEnum = schema.enums.find((e) =>
      e.name === col.udtName && e.schema === table.schema
    );
    if (foundEnum) {
      zodType = toPascalCase(foundEnum.name) + "Schema";
    } else {
      // Map basic types
      switch (col.dataType) {
        case "boolean":
          zodType = "z.boolean()";
          break;
        case "integer":
        case "smallint":
        case "real":
        case "double precision":
        case "numeric":
          zodType = "z.number()";
          break;
        case "bigint":
          zodType = "z.string()";
          break;
        case "text":
        case "character varying":
        case "character":
        case "uuid":
        case "inet":
        case "cidr":
        case "macaddr":
          zodType = "z.string()";
          break;
        case "timestamp with time zone":
        case "timestamp without time zone":
        case "date":
        case "time without time zone":
          // pREST returns strings for dates usually
          zodType = "z.string()";
          // Optionally: z.string().datetime() or similar if strict
          break;
        case "json":
        case "jsonb":
          zodType = "z.any()";
          break; // Zod doesn't have simple 'json', usually 'any' or recursive
        case "ARRAY":
          zodType = "z.array(z.unknown())";
          break; // Naive array
      }
    }

    if (col.isNullable) {
      zodType += ".nullable()";
    } else if (!col.hasDefault) {
      // It's required.
    }
    // If it has default, in Zod for input validation we might make it optional,
    // but here we are describing the SHAPE of the row in DB, so it's technically present.
    // However, usually these schemas are used for validation.
    // For Aether v2.1 MVP, we map Strict DB Shape.

    lines.push(`  ${col.name}: ${zodType},`);
  }

  lines.push(`});`);
  return lines;
}

function toPascalCase(str: string): string {
  return str.replace(/_(\w)/g, (_, c) => c.toUpperCase()).replace(
    /^[a-z]/,
    (c) => c.toUpperCase(),
  );
}
