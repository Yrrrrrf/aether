import type { DatabaseSchema, Table } from "../ast/types.ts";
import { mapPostgresTypeToTs } from "../ast/mapper.ts";

export function generateTypeScript(schema: DatabaseSchema): string {
  const lines: string[] = [];

  // Header
  lines.push(`// Generated by Aether Oracle`);
  lines.push(`// Do not edit manually`);
  lines.push(
    `import type { TableOperations, ViewOperations } from "@yrrrrrf/aether";`,
  );
  lines.push(``);
  lines.push(
    `export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];`,
  );
  lines.push(``);

  // Enums
  for (const enm of schema.enums) {
    const enumName = toPascalCase(enm.name);
    const validValues = enm.values.map((v) => `"${v}"`).join(" | ");
    lines.push(`export type ${enumName} = ${validValues};`);
    lines.push(``);
  }

  // Tables
  for (const table of schema.tables) {
    lines.push(...generateTable(table, schema));
    lines.push(...generateRelations(table, schema));
    lines.push(``);
  }

  // Main DB Interface
  lines.push(`export interface DB {`);
  // Group by schema
  const schemas = new Set(schema.tables.map((t) => t.schema));
  for (const s of schemas) {
    lines.push(`  ${s}: {`);
    const schemaTables = schema.tables.filter((t) => t.schema === s);
    for (const t of schemaTables) {
      const interfaceName = toPascalCase(t.name);
      const relationsName = `${interfaceName}Relations`;
      const wrapper = t.isView ? "ViewOperations" : "TableOperations";
      lines.push(`    ${t.name}: ${wrapper}<${interfaceName}, ${relationsName}>;`);
    }
    lines.push(`  };`);
  }
  lines.push(`}`);

  return lines.join("\n");
}

function generateRelations(table: Table, _schema: DatabaseSchema): string[] {
  const lines: string[] = [];
  const interfaceName = `${toPascalCase(table.name)}Relations`;

  lines.push(`export interface ${interfaceName} {`);
  for (const fk of table.foreignKeys) {
    const targetName = toPascalCase(fk.targetTable);
    // PostgREST convention: use the table name for the relationship
    lines.push(`  ${fk.targetTable}?: ${targetName};`);
  }
  lines.push(`}`);

  return lines;
}

function generateTable(table: Table, schema: DatabaseSchema): string[] {
  const lines: string[] = [];
  const interfaceName = toPascalCase(table.name);

  lines.push(`export interface ${interfaceName} {`);

  // Foreign Key Comments (The Graph)
  // We check table.foreignKeys
  if (table.foreignKeys.length > 0) {
    lines.push(`  // Relations:`);
    for (const fk of table.foreignKeys) {
      lines.push(
        `  // -> ${fk.column} joins to ${fk.targetSchema}.${fk.targetTable}.${fk.targetColumn}`,
      );
    }
  }

  for (const col of table.columns) {
    // Resolve type
    let tsType = mapPostgresTypeToTs(col.dataType, col.udtName, new Set());

    // Check if it is an enum
    const foundEnum = schema.enums.find((e) =>
      e.name === col.udtName && e.schema === table.schema
    );
    if (foundEnum) {
      tsType = toPascalCase(foundEnum.name);
    }

    if (col.dataType === "json" || col.dataType === "jsonb") {
      tsType = "Json";
    }

    const optionalMark = col.isNullable ? "?" : "";
    const nullType = col.isNullable ? " | null" : "";

    lines.push(`  ${col.name}${optionalMark}: ${tsType}${nullType};`);
  }

  lines.push(`}`);

  return lines;
}

function toPascalCase(str: string): string {
  return str.replace(/_(\w)/g, (_, c) => c.toUpperCase()).replace(
    /^[a-z]/,
    (c) => c.toUpperCase(),
  );
}
